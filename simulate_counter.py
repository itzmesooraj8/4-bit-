"""
Simple Python-based simulator for the parameterized counter testbench.
Generates a VCD file `counter_waveform.vcd` and prints pass/fail similar to the Verilog testbench.
"""

WIDTH = 4
PERIOD = 10      # ns
HALF = PERIOD/2  # ns
SIM_TIME = 210   # ns (run slightly longer than 200 ns)

def to_bin_list(val, width):
    return [(val >> i) & 1 for i in range(width)]

def vcd_header(f, timescale="1ns"):
    f.write("$date\n    Generated by simulate_counter.py\n$end\n")
    f.write(f"$timescale {timescale} $end\n")
    f.write("$scope module tb $end\n")
    f.write("$var wire 1 ! clk $end\n")
    f.write("$var wire 1 \" reset $end\n")
    for i in range(WIDTH):
        f.write(f"$var wire 1 {chr(35+i)} q{i} $end\n")
    f.write("$upscope $end\n$enddefinitions $end\n")

# Simulation
clk = 0
reset = 1
q = 0
expected = 0
error = False

# Prepare VCD
vcd_path = "C:\\Users\\itzme\\counter_project\\counter_waveform.vcd"
with open(vcd_path, 'w') as vcd:
    vcd_header(vcd)
    time = 0.0
    next_tog = HALF  # first toggle at half period since clk starts 0; but in tb clk toggles every 5ns so #5 invert -> so first toggle at 5

    # Dump initial values at time 0
    vcd.write("#0\n")
    vcd.write("0!\n")  # clk
    vcd.write("1\"\n")  # reset
    bits = to_bin_list(q, WIDTH)
    for i,b in enumerate(bits):
        vcd.write(f"{b}{chr(35+i)}\n")

    # run until SIM_TIME
    last_clk = clk
    posedge_count = 0
    while time <= SIM_TIME:
        # advance to next toggle time
        time = round(time + (next_tog - (time % next_tog)) if False else time, 12)
        # Simpler: step in 1 ns increments
        break

    # Simpler discrete-time simulation (1 ns steps)
    time = 0
    step = 1
    while time <= SIM_TIME:
        # toggle clock every HALF ns -> since HALF is 5 (int) we toggle when time % 5 == 0
        if time % int(HALF) == 0 and time != 0:
            clk = 0 if clk == 1 else 1
            vcd.write(f"#{time}\n")
            vcd.write(f"{int(clk)}!\n")
            vcd.write(f"{int(reset)}\"\n")
            bits = to_bin_list(q, WIDTH)
            for i,b in enumerate(bits):
                vcd.write(f"{b}{chr(35+i)}\n")

        # handle reset release: at 10 ns release reset
        if time == 10:
            reset = 0
            # write change
            vcd.write(f"#{time}\n")
            vcd.write(f"{int(clk)}!\n")
            vcd.write(f"{int(reset)}\"\n")
            bits = to_bin_list(q, WIDTH)
            for i,b in enumerate(bits):
                vcd.write(f"{b}{chr(35+i)}\n")

        # on posedge (we detect rising from previous time)
        # Determine if posedge occurs at this time: if clock goes from 0 to 1 between time-1 and time
        # For our discrete sim, when time%5==0 and clk becomes 1 after toggle
        if time % int(HALF) == 0:
            # We toggled at this time previously; compute clk at this time
            # Recompute clk value as (time/5) % 2 ?
            clk_now = ( (time // int(HALF)) % 2 )
            # posedge when clk_now == 1
            if clk_now == 1:
                # posedge
                if reset:
                    q = 0
                    expected = 0
                else:
                    q = (q + 1) & ((1<<WIDTH)-1)
                posedge_count += 1
                # Check expected: compare q to expected before increment? In Verilog testbench they compare q to expected after posedge and expected increments
                # Our tb increments expected after checking, so mimic that: here, we compare q to expected then increment expected
                # But above we already updated q; to mimic original tb, we'll compute expected value prior to posedge increment
                # For simplicity, we mirror behavior by checking q == expected (we set expected accordingly)
                # Print
                print(f"Time {time} ns: q = {q} (expected {expected})")
                if q != expected:
                    print(f"ERROR at time {time} ns: q={q} expected={expected}")
                    error = True
                expected = (expected + 1) & ((1<<WIDTH)-1)

        time += step

print('\nSimulation complete')
if not error:
    print('TEST PASSED: Counter incremented correctly')
else:
    print('TEST FAILED: See errors above')

print(f'Wrote VCD to {vcd_path}')
